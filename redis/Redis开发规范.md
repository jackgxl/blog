# <center>Redis开发规范

1、冷热数据分离，不要将所有数据全部都放到Redis中虽然Redis支持持久化，但是Redis的数据存储全部都是在内存中的，成本昂贵。建议根据业务只将高频热数据存储到Redis中【QPS大于5000】，对于低频冷数据可以使用MySQL/ElasticSearch/MongoDB等基于磁盘的存储方式，不仅节省内存成本，而且数据量小在操作时速度更快、效率更高！

2、不同的业务数据要分开存储不要将不相关的业务数据都放到一个Redis实例中，建议新业务申请新的单独实例。因为Redis为单线程处理，独立存储会减少不同业务相互操作的影响，提高请求响应速度；同时也避免单个实例内存数据量膨胀过大，在出现异常情况时可以更快恢复服务！



3.存储的Key一定要设置超时时间如果应用将Redis定位为缓存Cache使用，对于存放的Key一定要设置超时时间！因为若不设置，这些Key会一直占用内存不释放，造成极大的浪费，而且随着时间的推移会导致内存占用越来越大，直到达到服务器内存上限！另外Key的超时长短要根据业务综合评估，而不是越长越好！



4.对于必须要存储的大文本数据一定要压缩后存储对于大文本【超过500字节】写入到Redis时，一定要压缩后存储！大文本数据存入Redis，除了带来极大的内存占用外，在访问量高时，很容易就会将网卡流量占满，进而造成整个服务器上的所有服务不可用，并引发雪崩效应，造成各个系统瘫痪！



5.线上Redis禁止使用Keys正则匹配操作，Redis是单线程处理，在线上KEY数量较多时，操作效率极低【时间复杂度为O(N)】，该命令一旦执行会严重阻塞线上其它命令的正常请求，而且在高QPS情况下会直接造成Redis服务崩溃！如果有类似需求，请使用scan命令代替！

6.可靠的消息队列服务Redis List经常被用于消息队列服务。假设消费者程序在从队列中取出消息后立刻崩溃，但由于该消息已经被取出且没有被正常处理，那么可以认为该消息已经丢失，由此可能会导致业务数据丢失，或业务状态不一致等现象发生。为了避免这种情况，Redis提供了RPOPLPUSH命令，消费者程序会原子性的从主消息队列中取出消息并将其插入到备份队列中，直到消费者程序完成正常的处理逻辑后再将该消息从备份队列中删除。同时还可以提供一个守护进程，当发现备份队列中的消息过期时，可以重新将其再放回到主消息队列中，以便其它的消费者程序继续处理。

7.谨慎全量操作Hash、Set等集合结构在使用HASH结构存储对象属性时，开始只有有限的十几个field，往往使用HGETALL获取所有成员，效率也很高，但是随着业务发展，会将field扩张到上百个甚至几百个，此时还使用HGETALL会出现效率急剧下降、网卡频繁打满等问题【时间复杂度O(N)】,此时建议根据业务拆分为多个Hash结构；或者如果大部分都是获取所有属性的操作,可以将所有属性序列化为一个STRING类型存储！同样在使用SMEMBERS操作SET结构类型时也是相同的情况！

8.根据业务场景合理使用不同的数据结构类型目前Redis支持的数据库结构类型较多：字符串（String），哈希（Hash），列表（List），集合（Set），有序集合（Sorted Set）, Bitmap, HyperLogLog和地理空间索引（geospatial）等,需要根据业务场景选择合适的类型，常见的如：String可以用作普通的K-V、计数类；Hash可以用作对象如商品、经纪人等，包含较多属性的信息；List可以用作消息队列、粉丝/关注列表等；Set可以用于推荐；Sorted Set可以用于排行榜等！

9.<b>命名规范redis的key命名尽量简单明确，容易阅读理解，如：系统名+业务名+业务数据+其他</b>



10.线上禁止使用monitor命令禁止生产环境使用monitor命令，monitor命令在高并发条件下，会存在内存暴增和影响Redis性能的隐患



11.禁止大string核心集群禁用1mb的string大key(虽然redis支持512MB大小的string)，如果1mb的key每秒重复写入10次，就会导致写入网络IO达10MB; 



12.redis容量单实例的内存大小不建议过大，建议在10~20GB以内。redis实例包含的键个数建议控制在1kw内，单实例键个数过大，可能导致过期键的回收不及时





缓存(CACHE)：后端有真正持久化存储数据库(mysql、mongo、hbase)的redis服务。

```
注意事项：
* redis服务器端会设置(maxmemory、maxmemory-policy)达到所有key最少使用淘汰的效果。

* redis客户端需要设置所有key的过期时间，避免因为redis服务器端达到maxmemory进行淘汰key产生严重阻塞。    
* redis服务器端不做备份持久化。
mark: 电商库存自增自减需要做持久化，普通k/v应用应该强制使用过期时间，哪怕是设置一天，一个星期

```


队列(LIST):用于实时消费的redis服务。

```
注意事项：

* redis服务器端不做备份持久化。

* redis服务器端会监控队列长度，如果队列发生堵塞,redis客户端必须处理，防止发生故障。

* redis服务器端会监控队列长度的条件是在单实例key个数小于1000，否则不进行监控。mark: list必须尽快消费掉，否则内存会暴涨
```


订阅(PUB/SUB):用于发布订阅功能的redis服务。

```
注意事项:
     
1> redis服务器端不做备份持久化。
mark:寻找替代品，比如mq等

```


过期(EXPIRE):用于key带有过期时间的redis服务。

     注意事项：

     1> 目前我们的redis服务99%都是2.8版本及其以下版本，存在在从库读取过期key出现主从不一致的情况，解决办法redis客户端通过主库进行读取请求。

     2> 默认redis服务在从库做备份持久化。



     

存储(STORAGE):用于存储的(不包含缓存、队列、订阅、过期用途)redis服务

     注意事项：

     1> 默认redis服务在请求量比较低的(主/从)实例做备份持久化。



1 只使用0号数据库，而不使用多数据库。

    1）Redis是单线程的，如果使用多个数据库，那么这些数据库仍然是使用1个cpu，彼此之间还是会受影响。

    2）多数据库的使用方式，会让调试和运维不同业务的数据库变得困难。

    3）部分Redis客户端根本不支持多数据的方式。

    4) 默认非0数据库没有相关的监控指标。



2 查看所有key，线上环境由于keys该命令会产生严重阻塞而被禁用，可以使用scan渐进式遍历的方式查看。

    注意：

    在scan过程中如果有key的变化(增加、删除、修改)，那么遍历效果可能会碰到以下问题：

    1）新增的key可能没有遍历到

    2）遍历了重复的key



3 Redis提供了面向哈希类型、集合类型、有序集合类型的扫描遍历命令，诸如hgetall、smembers、zrange。
可能产生阻塞问题，对应的命令有hscan、scan、zscan，他们的用法和scan类似。

4 禁止长时间monitor，monitor会影响20%的性能，而且会导致内存暴涨